
# Web関係

## アプリケーション構成

### SPA

- 最初にスカスカのHTMLとアプリケーション本体のjsをダウンロードする
- 以降はHTMLは返らない、必要なデータだけをAPIサーバーとやり取りする
- ログインを要する管理アプリなどが向いているみたい
  - 人によって見るものが大きく変わるため(静的な部分が少ない)
- クライアント側の負荷が大きい

### SSR

- MPAのような感じ
- レンダリングをサーバーで行うものとクライアントで行うもので分ける
- HTMLはアクセスごとに返る、このときサーバー側である程度レンダリングされており、ユーザーごとに違う部分はクライアントサイドでレンダリングされる
- SEOに強いらしいが最近はそうでもない
- あとはクライアント側の負荷が少ない
  - 反面サーバーの負荷が大きい
- サーバーサイドの実装が大変
- サーバーを持たなきゃいけない
- リアルタイム性が求められるものに向いている

### SSG

- SSRのサーバー側のレンダリングを事前にやっておく
- コーポレートサイトやメディア、ECに向いているらしい
- リアルタイム性はそこまで求めない
- 負荷が少ないのでサーバー代が安い

### 参考

- [SPA, SSG, SSRはどんなアプリケーションに向いている？ （前編）](https://note.com/funteractive_inc/n/n3c7275b11b8d)

## クッキー

- HTTPリクエストはステートレス
- ログインの仕組みを実現させるためには、通信に識別番号を持たせたい
- ブラウザはその識別番号(セッションID)を覚えておく必要がある
- それをテキストとかで保存する仕組みがクッキー
- セッションはその識別番号を維持したやり取りの一連の流れ
- 実用では、識別番号が安易に推測されないようなものであることが大事

## CORS

- 基本的にブラウザはCSRFを防止するために異なるオリジンへのリソースのアクセスに成約をかけている
  - オリジン:スキーム、ホスト、ポートまで
- その一部を緩和し、異なるオリジン間でリソースを共有するための仕組みとしてCORSがある
- ある場所から別オリジンのリソースを参照したい場合、遷移元のオリジン情報が`Origin`ヘッダに追記される
- これに対し、遷移先はそれを受け入れるかどうかの設定ができる(`Access-Control-Allow-Origin`)
- リクエストには種類がある
  - 単純リクエスト
    - GET, HEAD, POSTのいずれか
    - Accept, Accept-Language, Content-Language, Content-Type, DPR, DownLink, Save-Data, Viewport-Width, Width 以外の HTTP ヘッダを送信していない
    - Content-Type が application/x-www-form-urlencoded, multipart/form-data, text/plain のいずれか
    - リクエストに使用される XMLHttpRequestUpload にイベントリスナーが登録されていない
    - リクエストに ReadableStream オブジェクトが使用されていない
- 単純リクエストでない場合、メインリクエストの前にプリフライトリクエストが発行される
  - OPTIONS
  - Access-Control-Request-Method
  - Origin
- 資格情報を含むリクエストは`Credentials`を利用する
  - Cookie
  - 認証ヘッダー
  - TLSクライアント証明書
- 基本的にクロスオリジンの場合はCookieを送付しない、同一の場合は送付する
  - オプションとしてはクロスオリジンの場合でも送信するものや、同一オリジンでも送信しないものなど

### 参考

- [CORS(Cross-Origin Resource Sharing)](https://www.tohoho-web.com/ex/cors.html)
- [CORSを絶対に理解する](https://zenn.dev/syo_yamamoto/articles/445ce152f05b02)

## CSRF

- 被害者が意図しないうちに、罠サイトからあるサイトへ悪意のあるリクエストを送信してしまうようにするもの
  - リクエスト強要
- 被害を受けるのは主にサーバー側、サーバー側で実行される(なりすまし的な意味ではクライアント側も)
- ログイン状態のものがよく取り上げられるが、それは本質ではなく、リクエストを検証せずに受け付けてしまうことが問題
  - パソコン遠隔操作事件
- 対策としては例えば以下
  - Synchronizer Token Pattern
    - クッキーにCSRF検証用のトークンを発行してそこに混ぜる
    - 攻撃者自身がサイトにアクセスした場合は、攻撃対象のユーザーとは別のセッションIDとトークンが返却されるので識別される

  ![CSRFトークン](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F99076%2F0c5dc7a2-e516-ca89-3e9e-7855ede5ae9f.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&w=1400&fit=max&s=6b86d49a9e0a724977805fab5ae63505)

  - クッキーのSameSite属性
    - Laxにすることで対策
      - 別ドメインに対して`GET`のみが許可される
      - ログイン中のアプリに対して、別アプリから遷移し直すと未ログイン扱いになる
    - 一番厳しいのは`strict`、別ドメインに対して`POST`や`GET`ができない
  - Referer(補助的)
    - そのページにアクセスする前にどのページにいたのかがレスポンスヘッダーにRefererとして含まれている
    - なので、同一オリジンかどうかを区別できる
    - ただし、これはセキュリティソフトなどで無効化されている場合がある
  - プリフライトリクエスト検証
    - ブラウザは、クロスオリジンかつ非同期リクエスト(ざっくり)の場合に実際の送信の前に`OPTION`メソッドを作ってプリフライトリクエストを発行する
    - このリクエストが正規のルートからのリクエストであるかを検証する
      - CORSチェックはプリフライトリクエスト
    - カスタムヘッダを付与する
      - カスタムヘッダが存在すること
      - `HOST`ヘッダが存在すること
      - `HOST`ヘッダが正規サービスのホスト名であること
      - `ORIGIN`ヘッダが`Access-Control-Allow-Origin`ヘッダと同じであること
- CORSの仕様によりクロスドメインは制限されるが、このときもリクエスト自体は宛先に到達している
  - 逆に、攻撃者がCSRFトークンを取得しようとしたとき。処理はされるがレスポンスを読み取らせてくれない

![CSRFトークン](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F99076%2Fb5d25563-b78d-f253-e7e3-f9ca2db80fe3.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&w=1400&fit=max&s=68b16a671a2fb08239bbc8af9fec0a82)

- SPAでは`Content-Type: application/json`にすることが多く(カスタムヘッダを追加)、こうすると原則としてプリフライトリクエストを伴う
- API側でリクエストの受付を`application/json`のみにしておくと確実
- ただし、同期リクエスト(htmlの`form`や`curlなど)ではCORSチェックを伴わないAPIリクエストが可能となる(単純リクエスト)
  - CORSチェックを伴わないのでCSRF攻撃が可能のように見えるが、この場合はカスタムヘッダを付与できないので一律で排除される
- 非同期リクエスト
  - カスタムヘッダを追加できる
  - プリフライトリクエストを伴うことが可能
- カスタムヘッダの追加が不可能
- CSRF対策で重要なのは、リクエストのコンテキストを検証すること
- SPAの場合、ログイン時ではなくて、もっと最初の段階でトークン発行したほうがいいのでは...?
- ワンタイムパスワードも対策のうち

- `axios`ではデフォルトでクッキーを送信しない
  - 使うときは`withCredentials = true`
  - つまりうちのやつはセッション情報を殆ど使っていない？
    - そんなことない気がするけど...
    - やっぱりクエリパラメータとして`id`渡したりしているので、あんまり使ってないかもしれん...
- サーバーとクライアントがIISで同一オリジンに乗っているので、CORSをあまり意識していないのかな
- SPAではトークンをどこに保存するのか問題があるらしい
  - Cookieにもたせている気が

### 参考

- [CSRF攻撃について](https://zenn.dev/yktakaha4/articles/study_csrf_attack)
- [Web API の CSRF 対策まとめ](https://qiita.com/okamoai/items/044c03680766f0609d41)
- [このWeb APIってCSRF対策出来てますか？って質問にこたえよう](https://qiita.com/maruloop/items/e14d02299bd136f4b1fc)
- [SPA + WebAPI でアプリケーションを構築するときの CSRF 対策についてのメモ](https://kimuson.dev/blog/%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89/csrf_spa/)

## XSS

- 不正なスクリプトがクライアントのWebサイト上で実行される
- 被害を受けるのはクライアント側、クライアント側で実行される(二次利用でサーバー側へも)
- 対策としてはサニタイズなど

## Keycloak

前提としてSAMLとOAuthについて

### SAML

- 認証や認可のための標準化されたマークアップ言語
  - 異なるドメイン間のアプリケーションやサービス感でのユーザー認証情報や許可情報を共有するために設計されている
- 主にSSOシステムで使用される
- 以下の主要な役割に基づく
  - サービスプロバイダ
    - ユーザーがアクセスしようとしているアプリケーションやサービスを提供する側
  - アイデンティティプロバイダ
    - ユーザーの認証情報を管理し、認証の結果やユーザーの属性をSAMLで提供する側
    - 通常ユーザーはここで認証され、その後SPに認証情報が渡される
- 以下のステップが実施される
  - 認証リクエスト
    - ユーザーがSPにアクセスしようとすると、SPはユーザーにりようが許可されているかどうかを確認する
    - ユーザーはIdPに認証トークンを発行してもらう
  - 認証
    - IdPは認証を行い、その結果をSAML Asserionと呼ばれるXMLに含めて返送する
    - ユーザーはそれをSPに渡す
  - アサーションの処理
    - SPは受け取ったアサーションを検証し、ユーザーが正当な認証を受けたことを確認する

![SAML](https://framerusercontent.com/images/TTq7dpa3j8DZlyo1hs0jrEz0IMs.png)

### OAuth

- 異なるサービス感でユーザーの認証情報を安全かつ制御可能な方法で共有するためのスタンダード
- サードパーティのアプリケーションがユーザーのリソースにアクセスするための委任されたアクセス権を取得するプロトコルとして使用される
- 以下の主要なコンポーネントで構成される
  - リソースオーナー
    - リソースへのアクセス権を与えるユーザー
    - Webアプリケーションを利用する人
  - リソースサーバー
    - リソースオーナーのデータを保持し、クライアントにデータのアクセスを許可するサーバー
    - アクセス対象のWebサーバー(Gmailなど)
  - クライアント
    - リソースオーナーのデータにアクセスするために権限を要求するアプリケーション
    - サードパーティのアプリケーションであり、リソースオーナーのデータにアクセスするためにOAuthを使用する
  - 認可サーバー
    - リソースサーバーと信頼関係にあり、クライアントにアクセストークンを発行するサーバー
- 以下のステップが実行される
  - ユーザーがログインを要求すると、クライアントから必要なパラメータを付与して認可サーバーへリダイレクトする
  - 認可サーバーは、リソースオーナーに対して要求されている認可の可否を確認する
    - リソースオーナーは必要に応じてパスワード等で認証を行ったあとに許可をする
  - 認可サーバーは許可されると、認可コードを発行し、クライアントへリダイレクトする
  - クライアントは認可コードを認可サーバーに渡してアクセストークンを取得する
  - ユーザーはアクセストークンを使用し、リソースサーバーがユーザーにログインを許可する
- 通常jsonが用いられる

### SAMLとOAuthの違い

- SAMLは認証と認可をするのに対して、OAuthは認可のみを行う
  - 認証はうユーザーのアイデンティティを識別する
  - 認可はユーザーにアクセス権限を与えるプロセス
- OAuthはアクセス後のユーザーの検証ができない(なりすましの検証ができない)

- Apach2.0ライセンス
  - OAuth
  - SAML
  - ソーシャルログイン
  - LDAP/Active Directory
  - ユーザーロール
  - 二要素認証
  - パスワードリカバリー
  - セッション管理

## 参考

- [SAMLとOAuthの違い](https://admina.moneyforward.com/jp/blog/saml-sso)
